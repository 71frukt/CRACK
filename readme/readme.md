# **Взлом кода**

## **1. Задание**
### 1.0 Общая информация
Задание выполнялось в парах, каждый должен был написать программу на ассемблере, предназначенную для взлома напарником, и кряк на Си, осуществляющий взлом.

### 1.1 Программа для взлома
Требовалось написать программу на языке ассемблера, производящую аутентификацию пользователя через пароль. Программа должна содержать две уязвимости разного уровня сложности для взлома через ввод пользователя (без использования сторонних программ).  

### 1.2 Кряк
Требовалось написать программу на Си, которая изменяла указанный исполняемый файл таким образом, чтобы он выдавал отчёт об успешном вводе пароля без использования правильного пароля. Программа должна иметь графический интерфейс, анимации, музыку, соответствующие уважающему себя кряку.

## 2. Выполнение задания: мои программы
### 2.1 Мои уязвимости в программе для взлома

### Простая уязвимость

Проверка пароля осуществляется путём определения его хеш-кода и сравнением с хеш-кодом, соответствующим правильному паролю. Конец ввода пароля пользователь должен помечать символом ARGS_END_ASCII = '\$', и расчёт хеш-кода ведется вплоть до его встречи. 
```
;-------------------------------------------------------
; Gets hash code of the specified string
; Entry:    ds:di = string terminating on ENTER_ASCII
; Exit:     ax    = hash code
; Destr:    bx, di
;-------------------------------------------------------
GetPswdHash     proc
        mov ax, 5381d   ; start val of hash
    
    next_char_to_hash:
        
        ; hash = hash * 32 + ds:[di++]
        mov bx, 32
        mul bx
        
        mov bl, byte ptr ds:[di]
        add ax, bx
        inc di

        cmp bx, ARGS_END_ASCII
        jne next_char_to_hash

        ret
        endp
;-------------------------------------------------------
```
    
Уязвимость заключается в расположении буфера для пароля и значения хеш-кода верного пароля:
```
PSWD_BUFFER         db PSWD_MAX_LEN dup(0)
CORRECT_PSWD_HASH   dw 4524h   ; hash of 'ARS LOH'
```
То есть если PSWD_MAX_LEN = 10, то такой пароль программа посчитает правильным:

![alt text](pswd_myprog.png)

Числа после '\$' не будут влиять на хеш, а последовательность байт `A0C4`, затирающая значение верного хеш-кода, соответствует хеш-коду пустого пароля (начинающегося с '$').

### Сложная уязвимость
Расположение буфера в конце сегмента данных позволяет ввести пароль такой длины, чтобы можно было дойти до конца сегмента и затереть стек, в частности, адрес возврата, который там лежит. Функция считывания пароля должна возвращаться к месту вызова, за которым следует функция нахождения хеша и затем сравнение его с верным.
```
24    ; get pswd
25        lea di, PSWD_BUFFER
26        call GetPswdToBuffer
27
28        call GetPswdHash        ; ax = hash
29        cmp ax, CORRECT_PSWD_HASH
30        
31        jne incorrect_pswd
32        lea dx, CORRECT_PSWD_STR
33        mov ah, 09h
34        int 21h
35        jmp exit
36
37    incorrect_pswd:
38        lea dx, INCORRECT_PSWD_STR
39        mov ah, 09h
40        int 21h
41
42    exit:
43        mov ax, 4c00h
44        int 21h
```

Однако переполнив буфер, мы можем изменить адрес возврата на такой, чтобы по выходе из функции GetPswdToBuffer происходил джамп на 32 строку (её адрес - 0x0118). Для создания такого пароля я написал программу на Си, которая создаёт файл и генерирует в него пароль, который после будет направлен в программу для взлома. Используя turbodebugger, можно определить точные адреса начала буфера, 32 строки и адреса возврата из функции GetPswdToBuffer: 

Снимок был сделан сразу после вызова функции GetPswdToBuffer.
![alt text](ret_addr_find.png)

Таким образом, направив получившийся файл программе для взлома на вход, получаем:

![alt text](get_access_proof.png)

### 2.2 Кряк
Программа представляет из себя графическое приложение. При запуске появляется dvd-рамка, оставляющая за собой след градиента. После нажатия на неё открывается диалоговое окно, спрашивающее, крякнуть указанную программу или выйти.
|![alt text](dvd_screen.png)|![alt text](dialog_screen.png)|
|---------------------------|------------------------------|

## 3. Выполнение задания: поиск уязвимостей в программе напарника
### 3.1 Простая уязвимость
Дизассемблировав код через IDA и проанализировав его, было обнаружено, что количество байт, выделенное в буфере для пароля (14h байт) не соответствовало тому, которое было записано в начало буфера для 21 прерывания (0Ah байт):

![alt text](int21_ars.png)
![alt text](buffer_ars.png)

То есть можно переполнить буфер, заменив следующую за вызовом прерывания команду на джамп на часть кода, отвечающую за правильный пароль. 

<img src="acess_granted_1_ars.png"  style="width: 50%;">

### 3.2 Сложная уязвимость
Для взлома этой уязвимости используем специальную ранее упомянутую программу - кряк. Она изменяет исходный код таким образом, чтобы программа для взлома исполняла тот код, который нам требуется. Для её написания определим, в каком месте эта программа определяет верность введенного пароля.

Введенный пароль сверяется с верным в этой части кода:

![jz2je](image.png)

Изменив команду jnz (номер 75) на jz (номер 74), получим, что любой пароль кроме верного подойдёт:

![alt text](access_2_proof.png)

Изменение исполняемого файла производится этой частью кода кряка:

```
const char *const COM_FILE_NAME = "CRACKEME.com";

const size_t COMMAND_ADDR = 0x76;
const char   NEW_COMMAND  = 0x74;   // je
```
```
void CrackProg()
{
    FILE *com_file = fopen(COM_FILE_NAME, "rb+");

    fseek(com_file, COMMAND_ADDR, SEEK_SET);
    fwrite(&NEW_COMMAND, 1, 1, com_file);

    return;
}
```

После работы кряка получаем взломанную программу, использование которой возможно без знания правильного пароля.